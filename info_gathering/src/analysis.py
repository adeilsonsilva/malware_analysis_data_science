#!/usr/bin/env python

##################################################
## Author: Joshua Saxe and Hillary Sanders, No Starch Press
## Source: https://www.malwaredatascience.com/
##################################################

"""
Copyright (c) 2015, Joshua Saxe
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name 'Joshua Saxe' nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL JOSHUA SAXE BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

import pefile
import sys
import argparse
import os
import pandas
import itertools
import pprint
import logging
import networkx
import collections
import tempfile
from networkx.drawing.nx_agraph import write_dot
from networkx.algorithms import bipartite

import hashlib

class ExtractImages():
    def __init__(self,target_binary):
        self.target_binary = target_binary
        self.image_basedir = None
        self.images = []

    def work(self):
        self.image_basedir = tempfile.mkdtemp()
        icondir = os.path.join(self.image_basedir,"icons")
        bitmapdir = os.path.join(self.image_basedir,"bitmaps")
        raw_resources = os.path.join(self.image_basedir,"raw")
        for directory in [icondir,bitmapdir,raw_resources]:
            os.mkdir(directory)
        rawcmd = "wrestool -x '{0}' -o '{1}' 2> /dev/null".format(self.target_binary,raw_resources)
        bmpcmd = "mv '{0}'/*.bmp '{1}' 2> /dev/null".format(raw_resources,bitmapdir)
        icocmd = "icotool -x '{0}'/*.ico -o '{1}' 2> /dev/null".format(raw_resources,icondir)
        for cmd in [rawcmd,bmpcmd,icocmd]:
            try:
                os.system(cmd)
            except Exception.msg:
                pass
        for dirname in [icondir,bitmapdir]:
            for path in os.listdir(dirname):
                logging.info(path)
                path = os.path.join(dirname,path)
                try:
                    imagehash = hashlib.sha256(open(path, 'rb').read()).hexdigest()
                except Exception as e:
                    print(e.msg)
                    imagehash = ''
                if path.endswith(".png"):
                    self.images.append((path,imagehash))
                if path.endswith(".bmp"):
                    self.images.append((path,imagehash))

    def cleanup(self):
        os.system("rm -rf {0}".format(self.image_basedir))

def gen_image_network(metadata_file, output_file, malware_projection, resource_projection):
    malware_data = pandas.read_csv(metadata_file, dtype=str, keep_default_na=False, skipinitialspace=True)

    network = networkx.Graph()

    # search the target directory for PE files to extract images from
    image_objects = []
    i = 1
    for malware_path in malware_data['FILE']:
        print("\t i: {}, j: {}, so: {}".format(i, malware_data['FILE'].size, i/malware_data['FILE'].size))
        i += 1
        # try to parse the path to see if it's a valid PE file
        try:
            pe = pefile.PE(malware_path)
        except pefile.PEFormatError:
            continue

        images = ExtractImages(malware_path)
        images.work()
        image_objects.append(images)

        # create the network by linking malware samples to their images
        filehash = hashlib.sha256(open(malware_path, 'rb').read()).hexdigest()
        node_name = malware_path.split("/")[-1] + '_' + str(filehash)
        if not node_name in network:
            network.add_node(node_name,type="malware")

        for path, image_hash in images.images:
            # set the image attribute on the image nodes to tell GraphViz to render images within these nodes
            if not image_hash in network:
                network.add_node(image_hash,image=path,label='',type='image')
            # node_name = path.split("/")[-1]
            print(node_name, image_hash)
            network.add_edge(node_name,image_hash)
    # write the bipartite network, then do the two projections and write them
    print(network)
    write_dot(network, output_file)
    malware = set(n for n,d in network.nodes(data=True) if d['type']=='malware')
    resource = set(network) - malware
    malware_network = bipartite.projected_graph(network, malware)
    resource_network = bipartite.projected_graph(network, resource)

    write_dot(malware_network, malware_projection)
    write_dot(resource_network, resource_projection)

    # images.cleanup()

def jaccard(set1,set2):
    """
    Compute the Jaccard distance between two sets by taking
    their intersection, union and then dividing the number
    of elements in the intersection by the number of elements
    in their union.
    """
    intersection = set1.intersection(set2)
    intersection_length = float(len(intersection))
    union = set1.union(set2)
    union_length = float(len(union))
    return intersection_length / union_length

def getstrings(fullpath):
    """
    Extract strings from the binary indicated by the 'fullpath'
    parameter, and then return the set of unique strings in
    the binary.
    """
    strings = os.popen("strings '{0}'".format(fullpath)).read()
    strings = set(strings.split("\n"))
    return strings

def pecheck(fullpath):
    """
    Do a cursory sanity check to make sure 'fullpath' is
    a Windows PE executable (PE executables start with the
    two bytes 'MZ')
    """
    try:
        pe = pefile.PE(fullpath)
        return True
    except pefile.PEFormatError:
        return False
    # return open(fullpath, 'rb').read(2).decode("utf-8") == "MZ"

def gen_strings_network(metadata_file, output_file, threshold):
    malware_data = pandas.read_csv(metadata_file, dtype=str, keep_default_na=False, skipinitialspace=True)

    malware_paths = malware_data['FILE'] # where we'll store the malware file paths
    malware_attributes = dict() # where we'll store the malware strings
    graph = networkx.Graph() # the similarity graph

    # filter out any paths that aren't PE files
    malware_paths = filter(pecheck, malware_paths)

    # get and store the strings for all of the malware PE files
    for path in malware_paths:
        attributes = getstrings(path)
        print("Extracted {0} attributes from {1} ...".format(len(attributes),path))
        malware_attributes[hashlib.sha256(open(path, 'rb').read()).hexdigest()] = attributes

        # add each malware file to the graph
        graph.add_node(path,label=hashlib.sha256(open(path, 'rb').read()).hexdigest()[:10])

    # iterate through all pairs of malware
    for malware1,malware2 in itertools.combinations(malware_paths,2):

        # compute the jaccard distance for the current pair
        jaccard_index = jaccard(malware_attributes[hashlib.sha256(open(malware1, 'rb').read()).hexdigest()],malware_attributes[hashlib.sha256(open(malware2, 'rb').read()).hexdigest()])

        # if the jaccard distance is above the threshold add an edge
        if jaccard_index > threshold:
            print(malware1,malware2,jaccard_index)
            graph.add_edge(malware1,malware2)
            # graph.add_edge(malware1,malware2,penwidth=1+(jaccard_index-threshold)*10)

    # write the graph to disk so we can visualize it
    write_dot(graph, output_file)
